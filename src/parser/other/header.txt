%{
    #include "../table_management/func_proc_manager.h"
    #include "../table_management/structure_manager.h"
    #include "../table_management/variable_manager.h"
    #include "../table_management/array_manager.h"

    #include "../symbol_table/declaration_table.h"
    #include "../symbol_table/hash_table.h"
    #include "../ast/ast.h"

    #include "../lexer/lexeme_table.h"
    #include "parser.h"

    #include "../utils/errors.h"

    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>

    int yylex();

    extern FILE *yyin;
    extern FILE *yyout;
    extern char *yytext;

    Error error;
    int current_lexeme_code;

    void yyerror(const char *s) {
        // TODO: Uncomment this line to prevent the program from exiting on syntax errors
        // TODO: Uncomment only if syntax errors are all handled properly in grammar rules
        // if (error.type == NO_ERROR) return;

        if (!strcmp(s, "syntax error")) {
            set_error_message(&error,
                "Unexpected token found: '%s'.\n"
                "\t> This error is critical and will cause the program to terminate.\n"
                "\t> Exiting due to a syntax error.",
                yytext);
        } 
        else {
            set_error_message(&error,
                "Unexpected token found: '%s'.\n"
                "\t> %s\n"
                "\t> This error is critical and will cause the program to terminate.\n"
                "\t> Exiting due to a syntax error.",
                yytext, s);
        }

        
        set_error_type(&error, SYNTAX_ERROR);
        yerror(error);
        
        exit(EXIT_FAILURE);
    }
%}

%union {
	int lexicographic_index;
    int ival;
    double fval;
}

